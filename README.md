# React Weather App

This is a dynamic weather application built with React that not only provides current weather conditions but also generates witty, AI-powered travel tips for any searched city. The backend is powered by Node.js and leverages the Google Gemini API for generating creative content.

## Live Demo

[View Live Demo](https://getweather-a.netlify.app/)

## Features

- Search for weather by city name.
- Display current temperature, min/max temperatures, and humidity.
- **AI-Powered Travel Tips:** Get a fun and clever travel tip for your destination, generated by Google's Gemini 2.0 Flash model.
- Shows a brief description of the weather (e.g., "broken clouds", "haze") and a dynamic weather icon.
- User-friendly interface with Material-UI components.
- Loading indicators and error handling for a smooth user experience.

## Tech Stack

- **Frontend:** [React.js](https://reactjs.org/)
- **UI Library:** [Material-UI](https://mui.com/)
- **HTTP Client:** [Axios](https://axios-http.com/)
- **Build Tool:** [Vite](https://vitejs.dev/)
- **Backend:** [Node.js](https://nodejs.org/), [Express.js](https://expressjs.com/)
- **AI:** [Google Gemini API](https://ai.google.dev/) (`gemini-2.0-flash`)

## Project Structure

The project is a monorepo with a `client` (the React app) and a `server` (the Node.js backend).

-   `src/`: Contains all the frontend source code.
    -   `WeatherApp.jsx`: The main container component that holds the application state.
    -   `SearchBox.jsx`: Handles user input and makes API calls to the backend server.
    -   `infoBox.jsx`: Displays the weather information and the AI-generated travel tip.
-   `server/`: Contains the backend source code.
    -   `server.js`: An Express server with a single endpoint (`/api/get-weather`) that communicates with both the OpenWeatherMap API and the Google Gemini API.

## Code Flow

The application follows a client-server architecture.

1.  **User Input**: The user enters a city name in the `SearchBox.jsx` component and clicks "Search".
2.  **Frontend to Backend**: `SearchBox.jsx` sends a POST request with the city name to the backend endpoint `/api/get-weather`.
3.  **Backend Processing**: The Node.js server in `server.js` receives the request.
    -   It first calls the **OpenWeatherMap API** to fetch the weather data for the specified city.
    -   It then constructs a prompt using the fetched weather data.
    -   This prompt is sent to the **Google Gemini API** to generate a creative travel tip.
4.  **Backend to Frontend**: The server combines the weather data and the AI-generated summary into a single JSON object and sends it back to the frontend as the response.
5.  **State Update**: `SearchBox.jsx` receives the data and uses the `updatedInfo` callback to lift the state up to the parent `WeatherApp.jsx` component.
6.  **UI Render**: The `WeatherApp.jsx` component's state is updated, causing a re-render. The `Infobox.jsx` component receives the new data as props and displays the complete weather report and the new AI travel tip.

## How to Run the Project

1.  **Clone the repository:**
    ```bash
    git clone <repository-url>
    ```

2.  **Setup Backend:**
    -   Navigate to the server directory:
        ```bash
        cd react-mini-project/server
        ```
    -   Install server dependencies:
        ```bash
        npm install
        ```
    -   Create a `.env` file in the `server` directory and add your API keys:
        ```
        OPENWEATHER_API_KEY=your_openweathermap_api_key
        GEMINI_API_KEY=your_google_gemini_api_key
        ```
    -   Start the backend server:
        ```bash
        node server.js
        ```
    The server will be running on `http://localhost:3001`.

3.  **Setup Frontend:**
    -   Open a new terminal and navigate to the project's root directory:
        ```bash
        cd react-mini-project
        ```
    -   Install frontend dependencies:
    ```bash
    npm install
    ```

4.  **Start the development server:**
    ```bash
    npm run dev
    ```

    The application will be available at `http://localhost:5173` (or another port if 5173 is busy) and will be able to communicate with your local backend.